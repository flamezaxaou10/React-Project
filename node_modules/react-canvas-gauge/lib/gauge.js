'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Gauge = function (_PureComponent) {
  _inherits(Gauge, _PureComponent);

  function Gauge(props) {
    _classCallCheck(this, Gauge);

    var _this = _possibleConstructorReturn(this, (Gauge.__proto__ || Object.getPrototypeOf(Gauge)).call(this, props));

    _this.getNewState = function () {
      var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var enableRefresh = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var newState = {};

      if (newProps.style !== oldProps.style) {
        newState.style = Object.assign({ WebkitUserSelect: 'none', MozUserSelect: 'none' }, newProps.style || {});
      }
      var isChange = !_this.state || enableRefresh || newProps.size !== oldProps.size || newProps.theme !== oldProps.theme || newProps.mode !== oldProps.mode;

      if (isChange) {
        var size = newProps.size || _this.props.size;
        var mode = newProps.mode || _this.props.mode;
        var theme = newProps.theme || _this.props.theme;
        var sizeInfo = {
          borderWidth: size * 0.05,
          barWidth: size * 0.1
        };
        var colorInfo = {};
        switch (mode) {
          case 'progress':
            {
              Object.assign(sizeInfo, {
                title: size * 0.15,
                value: size * 0.15,
                unit: size * 0.15
              });
              Object.assign(colorInfo, { pen: 'transparent' });
              break;
            }
          default:
            {
              Object.assign(sizeInfo, {
                title: size * 0.12,
                value: size * 0.15,
                unit: size * 0.15
              });
              Object.assign(colorInfo, { pen: 'red' });
              break;
            }
        }

        switch (theme) {
          case 'light':
            {
              Object.assign(colorInfo, {
                background: '#efefef',
                defaultBar: '#ababab',
                centerCircle: '#ffffff',
                text: '#000000',
                graduation: '#000000',
                border: '#efefef'
              });
              break;
            }
          case 'dark':
            {
              Object.assign(colorInfo, {
                pen: 'red',
                background: '#2e2e2e',
                defaultBar: '#c0c0c0',
                centerCircle: '#000000',
                text: '#ffffff',
                graduation: '#ffffff',
                border: '#000000'
              });
              break;
            }
          default:
            {
              break;
            }
        }
        Object.assign(newState, { colorInfo: colorInfo, sizeInfo: sizeInfo });
      }

      return newState;
    };

    _this.getValueRate = function () {
      var _this$props = _this.props,
          scaleList = _this$props.scaleList,
          minValue = _this$props.minValue,
          value = _this$props.value;


      if (scaleList && scaleList.length > 0) {
        var scaleNumber = scaleList.length;
        var intervalScale = (2.25 - 0.75) / scaleNumber;

        var tmpScale = 0;
        var tmpMinValue = minValue || 0;
        var tmpValue = value || 0;
        for (var i = 0; i < scaleNumber; i += 1) {
          var quantity = scaleList[i].quantity || 0;
          var scale = scaleList[i].scale || 0;
          var maxScaleValue = tmpMinValue + quantity * scale;

          if (maxScaleValue >= tmpValue) {
            tmpScale += (tmpValue - tmpMinValue) / (quantity * scale) * intervalScale;
            break;
          }
          tmpScale += intervalScale;
          tmpMinValue += quantity * scale;
        }

        var rateValue = parseFloat((tmpScale * 200 / 3 * 0.01).toFixed(2));
        if (rateValue < 0) {
          rateValue = 0.00;
        } else if (rateValue > 1) {
          rateValue = 1.00;
        }
        return rateValue;
      }

      return 0.00;
    };

    _this.isChangeGauge = function () {
      var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return newProps.style !== oldProps.style || newProps.theme !== oldProps.theme || newProps.mode !== oldProps.mode || newProps.size !== oldProps.size || newProps.colorInfo !== oldProps.colorInfo || newProps.title !== oldProps.title || newProps.unit !== oldProps.unit || newProps.enableColorful !== oldProps.enableColorful || newProps.scaleList !== oldProps.scaleList || newProps.minValue !== oldProps.minValue || newProps.value !== oldProps.value;
    };

    _this.refreshContext = function () {
      var newState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _this.setState(newState);
    };

    _this.drawProgress = function (valueRate) {
      var newState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _this$props2 = _this.props,
          size = _this$props2.size,
          mode = _this$props2.mode,
          enableColorful = _this$props2.enableColorful,
          title = _this$props2.title,
          unit = _this$props2.unit,
          scaleList = _this$props2.scaleList,
          minValue = _this$props2.minValue,
          value = _this$props2.value;


      var sizeInfo = newState.sizeInfo || _this.state.sizeInfo;
      var colorInfo = newState.colorInfo || _this.state.colorInfo;

      var gaugeDOM = _this.gaugue;
      if (gaugeDOM) {
        Object.assign(gaugeDOM, { width: size, height: size });
        var scaleNumber = scaleList.length > 0 ? scaleList.length : 1;

        var gaugeCTX = gaugeDOM.getContext('2d');

        var gaugeHalfWidth = gaugeDOM.width / 2;
        var gaugeHalfHeight = gaugeDOM.height / 2;
        var radiusWidth = gaugeDOM.width / 2 - sizeInfo.borderWidth;
        var scaleInterval = (2.25 - 0.75) / scaleNumber;
        // progress bar
        gaugeCTX.lineCap = 'round';

        switch (mode) {
          case 'progress':
            {
              // background ring
              gaugeCTX.beginPath();
              gaugeCTX.lineWidth = 0;
              gaugeCTX.fillStyle = colorInfo.background;
              gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, radiusWidth, 0, 2 * Math.PI);
              gaugeCTX.fill();

              gaugeCTX.beginPath();
              gaugeCTX.lineWidth = 0;
              gaugeCTX.fillStyle = colorInfo.centerCircle;
              gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, radiusWidth - sizeInfo.barWidth, 0.75 * Math.PI, 2.25 * Math.PI);
              gaugeCTX.fill();

              gaugeCTX.font = 'bold ' + sizeInfo.value + 'px Arial';
              gaugeCTX.textAlign = 'center';
              gaugeCTX.fillStyle = colorInfo.text;
              gaugeCTX.fillText('' + value + unit, gaugeHalfWidth, gaugeHalfHeight);

              gaugeCTX.font = 'bold ' + sizeInfo.title + 'px Arial';
              gaugeCTX.textAlign = 'center';
              gaugeCTX.fillStyle = colorInfo.text;
              gaugeCTX.fillText(title, gaugeHalfWidth, gaugeHalfHeight + radiusWidth - sizeInfo.barWidth / 2);

              // progress bar
              if (enableColorful) {
                gaugeCTX.beginPath();
                gaugeCTX.lineWidth = sizeInfo.barWidth;
                gaugeCTX.strokeStyle = colorInfo.defaultBar;
                gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, radiusWidth - sizeInfo.barWidth / 2, 0.75 * Math.PI, 2.25 * Math.PI);
                gaugeCTX.stroke();
              }

              var tmpValue = valueRate * 1.5;
              for (var i = 0; i < scaleNumber; i += 1) {
                var startAngle = (0.75 + i * scaleInterval) * Math.PI;
                var endAngle = (0.75 + (i + 1) * scaleInterval) * Math.PI;
                var startColor = scaleList[i].startColor;
                var endColor = scaleList[i].endColor;

                var isVauleInterval = (i + 1) * scaleInterval >= tmpValue;
                if (enableColorful) {
                  gaugeCTX.beginPath();
                  var tmpScale = isVauleInterval ? (0.75 + tmpValue) * Math.PI : endAngle;
                  var newRadiusWidth = radiusWidth - sizeInfo.barWidth / 2;
                  var barColor = gaugeCTX.createLinearGradient(gaugeHalfWidth + newRadiusWidth * Math.cos(startAngle), gaugeHalfHeight + newRadiusWidth * Math.sin(startAngle), gaugeHalfWidth + newRadiusWidth * Math.cos(tmpScale), gaugeHalfHeight + newRadiusWidth * Math.sin(tmpScale));

                  barColor.addColorStop(0, startColor);
                  barColor.addColorStop(1.0, endColor);

                  gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, radiusWidth - sizeInfo.barWidth / 2, startAngle, tmpScale);
                  gaugeCTX.lineWidth = sizeInfo.barWidth;
                  gaugeCTX.strokeStyle = barColor;
                  gaugeCTX.stroke();

                  if (isVauleInterval) {
                    break;
                  }
                } else if (isVauleInterval) {
                  gaugeCTX.beginPath();
                  var _barColor = gaugeCTX.createRadialGradient(gaugeHalfWidth, gaugeHalfHeight, radiusWidth, gaugeHalfWidth, gaugeHalfHeight, radiusWidth - sizeInfo.barWidth / 2);

                  gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, radiusWidth - sizeInfo.barWidth / 2, 0.75 * Math.PI, 2.25 * Math.PI);
                  gaugeCTX.lineWidth = sizeInfo.barWidth;
                  gaugeCTX.strokeStyle = _barColor;
                  gaugeCTX.stroke();
                  break;
                }
              }

              break;
            }
          default:
            {
              var graduationPosition = radiusWidth;
              var graduationLength = sizeInfo.barWidth;
              var graduationSize = gaugeDOM.width * 0.01;
              var graduationFontSize = Math.floor(gaugeDOM.width * 0.08);
              var penHalfWidth = gaugeDOM.width * 0.02;

              gaugeCTX.beginPath();
              gaugeCTX.lineWidth = 0;
              gaugeCTX.fillStyle = colorInfo.centerCircle;
              gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, radiusWidth, 0 * Math.PI, 2 * Math.PI);
              gaugeCTX.fill();

              var graduationValue = minValue || 0;
              for (var _i = 0; _i < scaleNumber; _i += 1) {
                var _startAngle = (0.75 + _i * scaleInterval) * Math.PI;
                var _endAngle = (0.75 + (_i + 1) * scaleInterval) * Math.PI;
                var quantity = scaleList[_i].quantity;
                var scale = scaleList[_i].scale;
                var intervalAngle = (_endAngle - _startAngle) / quantity;
                var _startColor = scaleList[_i].startColor;
                var _endColor = scaleList[_i].endColor;

                if (enableColorful) {
                  gaugeCTX.beginPath();
                  var _barColor2 = gaugeCTX.createLinearGradient(gaugeHalfWidth + (radiusWidth - graduationLength / 4) * Math.cos(_startAngle), gaugeHalfHeight + (radiusWidth - graduationLength / 4) * Math.sin(_startAngle), gaugeHalfWidth + (radiusWidth - graduationLength / 4) * Math.cos(_endAngle), gaugeHalfHeight + (radiusWidth - graduationLength / 4) * Math.sin(_endAngle));

                  _barColor2.addColorStop(0, _startColor);
                  _barColor2.addColorStop(1.0, _endColor);
                  gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, radiusWidth - graduationLength / 4, _startAngle, _endAngle);
                  gaugeCTX.lineWidth = graduationLength / 2;
                  gaugeCTX.strokeStyle = _barColor2;
                  gaugeCTX.stroke();
                }

                for (var j = 0; j <= quantity; j += 1) {
                  var angle = j * intervalAngle + _startAngle;

                  gaugeCTX.beginPath();
                  gaugeCTX.lineWidth = graduationSize;
                  gaugeCTX.strokeStyle = colorInfo.graduation;
                  gaugeCTX.moveTo(gaugeHalfWidth + graduationPosition * Math.cos(angle), gaugeHalfHeight + graduationPosition * Math.sin(angle));
                  gaugeCTX.lineTo(gaugeHalfWidth + (graduationPosition - graduationLength / 2) * Math.cos(angle), gaugeHalfHeight + (graduationPosition - graduationLength / 2) * Math.sin(angle));
                  gaugeCTX.stroke();
                  gaugeCTX.closePath();

                  var graduationText = '' + (graduationValue + j * scale);
                  gaugeCTX.font = graduationFontSize + 'px Arial';
                  gaugeCTX.textAlign = 'center';
                  gaugeCTX.fillStyle = colorInfo.graduation;
                  gaugeCTX.fillText(graduationText, gaugeHalfWidth + (graduationPosition - (graduationLength / 2 + graduationFontSize)) * Math.cos(angle), gaugeHalfHeight + (graduationPosition - (graduationLength / 2 + graduationFontSize)) * Math.sin(angle));
                }
                graduationValue += scale * quantity;
              }

              gaugeCTX.font = 'bold ' + sizeInfo.title + 'px Arial';
              gaugeCTX.textAlign = 'center';
              gaugeCTX.fillStyle = colorInfo.text;
              gaugeCTX.fillText(title, gaugeHalfWidth + graduationLength * Math.cos(1.5 * Math.PI), gaugeHalfHeight + graduationLength * Math.sin(1.5 * Math.PI));

              gaugeCTX.font = 'bold ' + sizeInfo.unit + 'px Arial';
              gaugeCTX.textAlign = 'center';
              gaugeCTX.fillStyle = colorInfo.text;
              gaugeCTX.fillText(unit, gaugeHalfWidth + radiusWidth / 2 * Math.cos(0.5 * Math.PI), gaugeHalfHeight + radiusWidth / 2 * Math.sin(0.5 * Math.PI));

              gaugeCTX.font = 'bold ' + sizeInfo.value + 'px Arial';
              gaugeCTX.textAlign = 'center';
              gaugeCTX.fillStyle = colorInfo.text;
              gaugeCTX.fillText(value, gaugeHalfWidth, gaugeHalfHeight + radiusWidth - sizeInfo.barWidth / 2);

              var valueAngle = ((2.25 - 0.75) * valueRate + 0.75) * Math.PI;
              gaugeCTX.beginPath();
              gaugeCTX.lineWidth = 0;
              gaugeCTX.fillStyle = colorInfo.pen;
              gaugeCTX.moveTo(gaugeHalfWidth + radiusWidth * Math.cos(valueAngle), gaugeHalfHeight + radiusWidth * Math.sin(valueAngle));

              valueAngle += 0.5 * Math.PI;
              gaugeCTX.lineTo(gaugeHalfWidth + penHalfWidth * Math.cos(valueAngle), gaugeHalfHeight + penHalfWidth * Math.sin(valueAngle));

              valueAngle -= 1 * Math.PI;
              gaugeCTX.lineTo(gaugeHalfWidth + penHalfWidth * Math.cos(valueAngle), gaugeHalfHeight + penHalfWidth * Math.sin(valueAngle));

              valueAngle += 0.5 * Math.PI;
              gaugeCTX.lineTo(gaugeHalfWidth + radiusWidth * Math.cos(valueAngle), gaugeHalfHeight + radiusWidth * Math.sin(valueAngle));
              gaugeCTX.fill();
              // center point
              gaugeCTX.beginPath();
              gaugeCTX.lineWidth = 0;
              gaugeCTX.fillStyle = colorInfo.pen;
              gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, penHalfWidth, 0, 2 * Math.PI);
              gaugeCTX.fill();

              break;
            }
        }

        gaugeCTX.beginPath();
        var borderColor = gaugeCTX.createRadialGradient(gaugeHalfWidth, gaugeHalfHeight, radiusWidth + sizeInfo.borderWidth, gaugeHalfWidth, gaugeHalfHeight, radiusWidth);

        borderColor.addColorStop(0, colorInfo.border);
        borderColor.addColorStop(0.5, '#ffffff');
        borderColor.addColorStop(1, colorInfo.border);

        gaugeCTX.lineWidth = sizeInfo.borderWidth;
        gaugeCTX.arc(gaugeHalfWidth, gaugeHalfHeight, radiusWidth + sizeInfo.borderWidth / 2, 0 * Math.PI, 2 * Math.PI);
        gaugeCTX.strokeStyle = borderColor;
        gaugeCTX.stroke();
        _this.state.valueBefore = valueRate;
      }
    };

    _this.clearLastAnimator = function () {
      if (_this.animatorTimeout) {
        clearTimeout(_this.animatorTimeout);
        _this.animatorTimeout = undefined;
      }
    };

    _this.animator = function (lastValue, optr, finalValue, timeout, newState) {
      var value = lastValue + optr;

      if (optr > 0 && value >= finalValue || optr < 0 && value <= finalValue) {
        value = finalValue;
      }

      _this.drawProgress(value, newState);
      if (value !== finalValue) {
        _this.animatorTimeout = setTimeout(function () {
          _this.animator(value, optr, finalValue, timeout, newState);
        }, timeout);
      }
    };

    _this.state = _this.getNewState(props);
    return _this;
  }

  _createClass(Gauge, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var newState = this.getNewState(this.props, undefined, true);
      this.drawProgress(this.getValueRate(), newState);
      this.refreshContext(newState);
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var newState = this.getNewState(this.props, prevProps);
      var isChangeGauge = this.isChangeGauge(this.props, prevProps);
      if (isChangeGauge) {
        var valueRate = this.getValueRate();
        if (this.props.enableAnimation && this.state.valueBefore !== valueRate) {
          var subValue = valueRate - this.state.valueBefore;
          var time = Math.abs(subValue) * 100 || 1;
          var optr = subValue > 0 ? 0.01 : -0.01;
          var timeout = this.props.animationTimeout / time;

          this.clearLastAnimator();
          this.animator(this.state.valueBefore, optr, valueRate, timeout, newState);
        } else {
          this.drawProgress(this.getValueRate(), newState);
        }
        this.refreshContext(newState);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var style = this.state.style;

      return _react2.default.createElement('canvas', { style: style, ref: function ref(g) {
          _this2.gaugue = g;
        } });
    }
  }]);

  return Gauge;
}(_react.PureComponent);

Gauge.propTypes = {
  style: _propTypes2.default.object,
  theme: _propTypes2.default.oneOf(['light', 'dark']),
  mode: _propTypes2.default.oneOf(['gauge', 'progress']),
  size: _propTypes2.default.number,
  enableAnimation: _propTypes2.default.bool,
  animationTimeout: _propTypes2.default.number,
  enableColorful: _propTypes2.default.bool,
  title: _propTypes2.default.string,
  unit: _propTypes2.default.string,
  scaleList: _propTypes2.default.arrayOf(_propTypes2.default.shape({
    scale: _propTypes2.default.number,
    quantity: _propTypes2.default.number,
    startColor: _propTypes2.default.string,
    endColor: _propTypes2.default.string
  })),
  minValue: _propTypes2.default.number,
  value: _propTypes2.default.number
};
Gauge.defaultProps = {
  style: {},
  theme: 'light',
  mode: 'gauge',
  size: 128,
  enableAnimation: true,
  animationTimeout: 250,
  enableColorful: true,
  title: '',
  unit: '',
  scaleList: [{ scale: 10, quantity: 5, startColor: '#ff2a04', endColor: 'orange' }, { scale: 10, quantity: 5, startColor: 'orange', endColor: '#32cd32' }],
  minValue: 0,
  value: 0
};
exports.default = Gauge;
module.exports = exports['default'];
//# sourceMappingURL=gauge.js.map